---
title: 2019/Feb/5th - New Year Chaos
layout: post
comments: true
social-share: true
show-avatar: true
tags:
- implementation
---

> https://www.hackerrank.com/challenges/new-year-chaos/problem

## 문제 요약

1. [1 .... N] 으로  원소가 1씩 증가하는 정렬 된 배열의 N이 문제로 주어짐
2. 각 원소는 원래의 자리보다 최대 2칸 앞까지 이동할 수 있음
3. 이동은 `bubbling` 형태 (가고싶은 자리로 바로 swap이 아닌 한칸씩 swap하면서 이동)
4. 검증을 원하는 배열이 위의 조건을 만족하지 못할 경우 `Too chaotic`을 출력하고, 만족할 경우 몇번의 swap이 필요한지 출력

## 숨은 조건

1. 앞의 숫자가 뒤로는 무한정 이동할 수 있다. 
 예를 들어 `[1,2,3,4,5]` 배열이 있을 때, *2*가 *1*로 이동하면 `[2,1,3,4,5]`. 다시 3이 앞으로 이동하면, `[2,3,1,4,5]`. 다시 4가 앞으로 이동하면, `[2,3,4,1,5]`. 다시 5가 앞으로 이동하면, `[2,3,4,5,1]`의 형태가 가능하다. 이를 통해 작은 숫자가 뒤로 이동한 거리는 상관이 없음을 알 수 있다.
 
 2. 위의 조건의 예제에서 알 수 있듯이, 실제 swap 한 횟수는 작은 숫자가 swap 당한 횟수와 일치함. 

## 풀이법

1. 배열의 뒤부터 검사를 시작, 일단 원소의 위치가 원래 위치보다 2 초과하여 멀어졌을 경우 `Too chaotic`
2. 그렇지 않을 경우, 현재 원소보다 앞에 있는 원소들 중 현재 원소보다 더 큰 원소의 갯수를 셈. 현재 원소보다 큰 원소가 앞에 있으려면, 현재 원소를 대상으로 swap을 수행했어야 가능한 일이므로 조건을 만족하는 계산법이 됨.
3. 다 더해서 출력하면 끝